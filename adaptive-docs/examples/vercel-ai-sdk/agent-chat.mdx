---
title: 'Vercel AI SDK Agent Chat'
description: 'Build intelligent agents with tools using Vercel AI SDK and Adaptive routing'
---

## Overview

This example demonstrates how to build intelligent AI agents with tool capabilities using the Vercel AI SDK and Adaptive's intelligent routing. The agents can perform actions, access APIs, and provide interactive experiences.

## Prerequisites

- Next.js 14+
- Node.js 18+
- Adaptive API key

## Installation

```bash
npm install ai @ai-sdk/openai zod
```

## Basic Agent with Tools

### Tool Definition

```typescript lib/tools.ts
import { tool } from 'ai';
import { z } from 'zod';

// Weather tool
export const getWeatherTool = tool({
  description: 'Get the current weather for a location',
  parameters: z.object({
    location: z.string().describe('The city and state, e.g. San Francisco, CA'),
    unit: z.enum(['celsius', 'fahrenheit']).optional().describe('Temperature unit'),
  }),
  execute: async ({ location, unit = 'fahrenheit' }) => {
    // Simulate API call - replace with real weather API
    const weatherData = {
      location,
      temperature: unit === 'celsius' ? 22 : 72,
      condition: 'Sunny',
      humidity: 65,
      windSpeed: '10 mph',
      unit
    };

    return {
      location,
      current: weatherData,
      description: `The weather in ${location} is ${weatherData.condition} with a temperature of ${weatherData.temperature}¬∞${unit === 'celsius' ? 'C' : 'F'}.`
    };
  },
});

// Search tool
export const searchTool = tool({
  description: 'Search the web for current information',
  parameters: z.object({
    query: z.string().describe('The search query'),
    maxResults: z.number().optional().describe('Maximum number of results to return'),
  }),
  execute: async ({ query, maxResults = 5 }) => {
    // Simulate search - replace with real search API
    const searchResults = [
      {
        title: `Search result for "${query}"`,
        url: 'https://example.com/result1',
        snippet: `This is a simulated search result for the query: ${query}. In a real implementation, this would return actual search results.`
      },
      {
        title: `Another result for "${query}"`,
        url: 'https://example.com/result2', 
        snippet: `Additional information about ${query} from various sources on the web.`
      }
    ];

    return {
      query,
      results: searchResults.slice(0, maxResults),
      totalResults: searchResults.length
    };
  },
});

// Calculator tool
export const calculatorTool = tool({
  description: 'Perform mathematical calculations',
  parameters: z.object({
    expression: z.string().describe('Mathematical expression to evaluate (e.g., "2 + 2", "sqrt(16)")'),
  }),
  execute: async ({ expression }) => {
    try {
      // Simple calculator - in production, use a proper math library
      const sanitizedExpression = expression.replace(/[^0-9+\-*/().\s]/g, '');
      const result = eval(sanitizedExpression);
      
      return {
        expression,
        result,
        success: true
      };
    } catch (error) {
      return {
        expression,
        error: 'Invalid mathematical expression',
        success: false
      };
    }
  },
});

// Code execution tool
export const codeExecutorTool = tool({
  description: 'Execute JavaScript code safely',
  parameters: z.object({
    code: z.string().describe('JavaScript code to execute'),
    timeout: z.number().optional().describe('Timeout in milliseconds (default: 5000)'),
  }),
  execute: async ({ code, timeout = 5000 }) => {
    try {
      // In a real implementation, use a sandboxed environment
      const result = eval(code);
      
      return {
        code,
        result: String(result),
        success: true,
        executionTime: '<1ms'
      };
    } catch (error) {
      return {
        code,
        error: error.message,
        success: false
      };
    }
  },
});

// All available tools
export const availableTools = {
  getWeather: getWeatherTool,
  search: searchTool,
  calculate: calculatorTool,
  executeCode: codeExecutorTool,
};
```

### API Route with Tools

```typescript app/api/agent-chat/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText, convertToCoreMessages } from 'ai';
import { availableTools } from '@/lib/tools';

// Configure Adaptive OpenAI
const adaptiveOpenAI = openai({
  apiKey: process.env.ADAPTIVE_API_KEY!,
  baseURL: 'https://llmadaptive.uk/api/v1',
});

export async function POST(req: Request) {
  try {
    const { messages } = await req.json();

    const result = await streamText({
      model: adaptiveOpenAI(''), // Intelligent routing
      messages: convertToCoreMessages(messages),
      tools: availableTools,
      toolChoice: 'auto',
      temperature: 0.7,
      maxToolRoundtrips: 3, // Allow multiple tool calls
      system: `You are a helpful AI assistant with access to various tools. You can:

1. **Get Weather Information**: Check current weather conditions for any location
2. **Search the Web**: Find current information on any topic
3. **Perform Calculations**: Solve mathematical problems and equations
4. **Execute Code**: Run JavaScript code safely

When using tools:
- Always explain what you're doing before calling a tool
- Provide context for the results you get from tools
- If a tool fails, explain the issue and suggest alternatives
- Use multiple tools together when needed to provide comprehensive answers

Be helpful, accurate, and provide clear explanations for your actions.`,
    });

    return result.toAIStreamResponse();

  } catch (error) {
    console.error('Agent chat error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { 
        status: 500, 
        headers: { 'Content-Type': 'application/json' } 
      }
    );
  }
}
```

## Advanced Agent Interface

### React Component with Tool Display

```tsx components/AgentChat.tsx
'use client';

import { useChat } from 'ai/react';
import { useState, useRef, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Badge } from '@/components/ui/badge';
import { 
  Bot, 
  User, 
  Send, 
  Loader2, 
  Cloud, 
  Search, 
  Calculator, 
  Code,
  Tool
} from 'lucide-react';

const toolIcons = {
  getWeather: Cloud,
  search: Search,
  calculate: Calculator,
  executeCode: Code,
};

interface ToolCall {
  name: string;
  parameters: any;
  result?: any;
}

export default function AgentChat() {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [toolCalls, setToolCalls] = useState<Record<string, ToolCall[]>>({});

  const { 
    messages, 
    input, 
    handleInputChange, 
    handleSubmit, 
    isLoading,
    data
  } = useChat({
    api: '/api/agent-chat',
    onFinish: (message) => {
      // Extract tool calls from the message data
      if (data && data.length > 0) {
        const messageToolCalls = data[data.length - 1]?.toolCalls || [];
        if (messageToolCalls.length > 0) {
          setToolCalls(prev => ({
            ...prev,
            [message.id]: messageToolCalls
          }));
        }
      }
    },
  });

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const renderToolCall = (toolCall: ToolCall) => {
    const IconComponent = toolIcons[toolCall.name as keyof typeof toolIcons] || Tool;
    
    return (
      <div key={toolCall.name} className="bg-blue-50 rounded-lg p-3 mt-2 border border-blue-200">
        <div className="flex items-center gap-2 mb-2">
          <IconComponent className="h-4 w-4 text-blue-600" />
          <span className="text-sm font-medium text-blue-700">
            {toolCall.name}
          </span>
          <Badge variant="secondary" className="text-xs">
            Tool Call
          </Badge>
        </div>
        
        <div className="text-xs text-gray-600 mb-2">
          <strong>Parameters:</strong>
          <pre className="mt-1 bg-gray-100 p-2 rounded text-xs overflow-x-auto">
            {JSON.stringify(toolCall.parameters, null, 2)}
          </pre>
        </div>
        
        {toolCall.result && (
          <div className="text-xs text-gray-600">
            <strong>Result:</strong>
            <pre className="mt-1 bg-green-50 p-2 rounded text-xs overflow-x-auto border border-green-200">
              {typeof toolCall.result === 'string' 
                ? toolCall.result 
                : JSON.stringify(toolCall.result, null, 2)
              }
            </pre>
          </div>
        )}
      </div>
    );
  };

  return (
    <Card className="w-full max-w-4xl mx-auto h-[80vh] flex flex-col">
      <CardHeader className="border-b bg-gradient-to-r from-blue-50 to-purple-50">
        <CardTitle className="flex items-center gap-2">
          <Bot className="h-6 w-6 text-blue-600" />
          AI Agent Assistant
          <span className="ml-auto text-sm font-normal text-gray-500">
            With Tools & Actions
          </span>
        </CardTitle>
        <div className="flex gap-2 mt-2">
          <Badge variant="outline" className="text-xs">
            <Cloud className="h-3 w-3 mr-1" />
            Weather
          </Badge>
          <Badge variant="outline" className="text-xs">
            <Search className="h-3 w-3 mr-1" />
            Search
          </Badge>
          <Badge variant="outline" className="text-xs">
            <Calculator className="h-3 w-3 mr-1" />
            Math
          </Badge>
          <Badge variant="outline" className="text-xs">
            <Code className="h-3 w-3 mr-1" />
            Code
          </Badge>
        </div>
      </CardHeader>

      <CardContent className="flex-1 flex flex-col p-0">
        <ScrollArea className="flex-1 p-6">
          <div className="space-y-4">
            {messages.length === 0 && (
              <div className="text-center text-gray-500 py-8">
                <Bot className="h-16 w-16 mx-auto mb-4 text-gray-300" />
                <p className="text-lg font-medium">AI Agent Ready!</p>
                <p className="text-sm mb-4">I can help you with:</p>
                <div className="grid grid-cols-2 gap-4 max-w-md mx-auto">
                  <div className="text-left">
                    <p className="font-medium">üå§Ô∏è Weather</p>
                    <p className="text-xs text-gray-500">Current conditions anywhere</p>
                  </div>
                  <div className="text-left">
                    <p className="font-medium">üîç Search</p>
                    <p className="text-xs text-gray-500">Find current information</p>
                  </div>
                  <div className="text-left">
                    <p className="font-medium">üßÆ Math</p>
                    <p className="text-xs text-gray-500">Solve calculations</p>
                  </div>
                  <div className="text-left">
                    <p className="font-medium">üíª Code</p>
                    <p className="text-xs text-gray-500">Execute JavaScript</p>
                  </div>
                </div>
              </div>
            )}

            {messages.map((message) => (
              <div
                key={message.id}
                className={`flex items-start gap-3 ${
                  message.role === 'user' ? 'justify-end' : 'justify-start'
                }`}
              >
                {message.role === 'assistant' && (
                  <div className="flex-shrink-0 w-8 h-8 bg-gradient-to-br from-blue-100 to-purple-100 rounded-full flex items-center justify-center">
                    <Bot className="h-4 w-4 text-blue-600" />
                  </div>
                )}
                
                <div className={`max-w-[85%] ${message.role === 'user' ? 'order-2' : ''}`}>
                  <div
                    className={`rounded-lg px-4 py-2 ${
                      message.role === 'user'
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-100 text-gray-900'
                    }`}
                  >
                    <div className="whitespace-pre-wrap">{message.content}</div>
                  </div>
                  
                  {/* Show tool calls for assistant messages */}
                  {message.role === 'assistant' && toolCalls[message.id] && (
                    <div className="mt-2">
                      {toolCalls[message.id].map((toolCall, index) => (
                        <div key={index}>
                          {renderToolCall(toolCall)}
                        </div>
                      ))}
                    </div>
                  )}
                </div>

                {message.role === 'user' && (
                  <div className="flex-shrink-0 w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center order-1">
                    <User className="h-4 w-4 text-gray-600" />
                  </div>
                )}
              </div>
            ))}

            {isLoading && (
              <div className="flex items-start gap-3">
                <div className="flex-shrink-0 w-8 h-8 bg-gradient-to-br from-blue-100 to-purple-100 rounded-full flex items-center justify-center">
                  <Bot className="h-4 w-4 text-blue-600" />
                </div>
                <div className="bg-gray-100 rounded-lg px-4 py-2">
                  <div className="flex items-center gap-2">
                    <Loader2 className="h-4 w-4 animate-spin" />
                    <span>Agent is thinking and using tools...</span>
                  </div>
                </div>
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>
        </ScrollArea>

        <div className="border-t p-4 bg-gray-50">
          <form onSubmit={handleSubmit} className="flex gap-2">
            <Input
              value={input}
              onChange={handleInputChange}
              placeholder="Ask me anything! I can check weather, search, calculate, or run code..."
              disabled={isLoading}
              className="flex-1 bg-white"
            />
            <Button type="submit" disabled={isLoading || !input.trim()}>
              <Send className="h-4 w-4" />
            </Button>
          </form>
          <div className="text-xs text-gray-500 mt-2">
            Try: "What's the weather in Tokyo?", "Search for AI news", "Calculate 15% of 200", "Run: console.log('Hello')"
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

## Specialized Agent Examples

### Customer Support Agent

```typescript app/api/support-agent/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText, tool } from 'ai';
import { z } from 'zod';

const adaptiveOpenAI = openai({
  apiKey: process.env.ADAPTIVE_API_KEY!,
  baseURL: 'https://llmadaptive.uk/api/v1',
});

// Support-specific tools
const checkOrderTool = tool({
  description: 'Check the status of a customer order',
  parameters: z.object({
    orderId: z.string().describe('The order ID to check'),
  }),
  execute: async ({ orderId }) => {
    // Simulate order lookup
    return {
      orderId,
      status: 'Shipped',
      trackingNumber: 'TRK123456789',
      estimatedDelivery: '2024-01-15',
      items: [
        { name: 'Product A', quantity: 1, price: 29.99 },
        { name: 'Product B', quantity: 2, price: 15.50 }
      ]
    };
  },
});

const createTicketTool = tool({
  description: 'Create a support ticket for customer issues',
  parameters: z.object({
    issue: z.string().describe('Description of the customer issue'),
    priority: z.enum(['low', 'medium', 'high']).describe('Priority level'),
    category: z.string().describe('Issue category (e.g., billing, technical, shipping)'),
  }),
  execute: async ({ issue, priority, category }) => {
    const ticketId = Math.random().toString(36).substr(2, 9).toUpperCase();
    
    return {
      ticketId,
      issue,
      priority,
      category,
      status: 'open',
      createdAt: new Date().toISOString(),
      estimatedResolution: '24-48 hours'
    };
  },
});

export async function POST(req: Request) {
  try {
    const { messages } = await req.json();

    const result = await streamText({
      model: adaptiveOpenAI(''),
      messages,
      tools: {
        checkOrder: checkOrderTool,
        createTicket: createTicketTool,
      },
      system: `You are a friendly and helpful customer support agent. Your role is to:

1. **Assist customers** with their questions and concerns professionally
2. **Check order status** when customers provide order IDs
3. **Create support tickets** for complex issues that need follow-up
4. **Provide accurate information** about company policies and procedures
5. **Escalate issues** when necessary

Guidelines:
- Always be polite and empathetic
- Ask for clarification when needed
- Use tools to get accurate, real-time information
- Explain next steps clearly
- Offer alternatives when possible

If you can't resolve an issue immediately, create a support ticket and explain the follow-up process.`,
      temperature: 0.3, // Lower temperature for consistent, professional responses
    });

    return result.toAIStreamResponse();

  } catch (error) {
    console.error('Support agent error:', error);
    return new Response('Error processing request', { status: 500 });
  }
}
```

### Data Analysis Agent

```typescript app/api/data-agent/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText, tool } from 'ai';
import { z } from 'zod';

const adaptiveOpenAI = openai({
  apiKey: process.env.ADAPTIVE_API_KEY!,
  baseURL: 'https://llmadaptive.uk/api/v1',
});

// Data analysis tools
const analyzeDataTool = tool({
  description: 'Analyze numerical data and provide statistical insights',
  parameters: z.object({
    data: z.array(z.number()).describe('Array of numerical data points'),
    analysisType: z.enum(['basic', 'detailed', 'trend']).describe('Type of analysis to perform'),
  }),
  execute: async ({ data, analysisType }) => {
    if (data.length === 0) {
      return { error: 'No data provided for analysis' };
    }

    const sorted = [...data].sort((a, b) => a - b);
    const sum = data.reduce((a, b) => a + b, 0);
    const mean = sum / data.length;
    const median = sorted[Math.floor(sorted.length / 2)];
    const min = Math.min(...data);
    const max = Math.max(...data);
    const range = max - min;
    
    // Calculate standard deviation
    const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.length;
    const stdDev = Math.sqrt(variance);

    const basicStats = {
      count: data.length,
      sum,
      mean: Number(mean.toFixed(2)),
      median,
      min,
      max,
      range,
      standardDeviation: Number(stdDev.toFixed(2))
    };

    if (analysisType === 'basic') {
      return { statistics: basicStats };
    }

    // Detailed analysis
    const quartiles = {
      q1: sorted[Math.floor(sorted.length * 0.25)],
      q3: sorted[Math.floor(sorted.length * 0.75)]
    };

    const outliers = data.filter(val => 
      val < quartiles.q1 - 1.5 * (quartiles.q3 - quartiles.q1) ||
      val > quartiles.q3 + 1.5 * (quartiles.q3 - quartiles.q1)
    );

    return {
      statistics: basicStats,
      quartiles,
      outliers,
      interpretation: `Dataset has ${data.length} points with mean ${mean.toFixed(2)} and standard deviation ${stdDev.toFixed(2)}. ${outliers.length > 0 ? `Found ${outliers.length} outliers.` : 'No outliers detected.'}`
    };
  },
});

const generateChartTool = tool({
  description: 'Generate chart configuration for data visualization',
  parameters: z.object({
    data: z.array(z.object({
      label: z.string(),
      value: z.number()
    })).describe('Data points with labels and values'),
    chartType: z.enum(['bar', 'line', 'pie', 'scatter']).describe('Type of chart to generate'),
  }),
  execute: async ({ data, chartType }) => {
    return {
      chartType,
      data,
      config: {
        title: `${chartType.charAt(0).toUpperCase() + chartType.slice(1)} Chart`,
        xAxis: 'Categories',
        yAxis: 'Values',
        colors: ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6']
      },
      description: `Generated ${chartType} chart configuration for ${data.length} data points`
    };
  },
});

export async function POST(req: Request) {
  try {
    const { messages } = await req.json();

    const result = await streamText({
      model: adaptiveOpenAI(''),
      messages,
      tools: {
        analyzeData: analyzeDataTool,
        generateChart: generateChartTool,
      },
      system: `You are a data analysis expert. Your role is to:

1. **Analyze numerical data** and provide statistical insights
2. **Generate visualizations** to help understand data patterns
3. **Interpret results** in business-friendly language
4. **Identify trends and anomalies** in datasets
5. **Recommend actions** based on data findings

When working with data:
- Always validate data quality first
- Provide both statistical details and plain-language interpretations
- Suggest appropriate visualization types for different data
- Explain the significance of findings
- Recommend next steps for further analysis

Use the available tools to perform calculations and generate chart configurations.`,
      temperature: 0.2, // Lower temperature for consistent analytical approach
    });

    return result.toAIStreamResponse();

  } catch (error) {
    console.error('Data agent error:', error);
    return new Response('Error processing request', { status: 500 });
  }
}
```

## Multi-Agent Orchestration

### Agent Router

```typescript app/api/agent-router/route.ts
import { openai } from '@ai-sdk/openai';
import { generateText, streamText } from 'ai';

const adaptiveOpenAI = openai({
  apiKey: process.env.ADAPTIVE_API_KEY!,
  baseURL: 'https://llmadaptive.uk/api/v1',
});

// Agent endpoints
const AGENT_ENDPOINTS = {
  support: '/api/support-agent',
  data: '/api/data-agent',
  general: '/api/agent-chat',
  code: '/api/code-agent',
};

async function routeToAgent(message: string): Promise<string> {
  const { text } = await generateText({
    model: adaptiveOpenAI(''),
    prompt: `Analyze this user message and determine which specialized agent should handle it:

Message: "${message}"

Available agents:
1. "support" - Customer support, orders, billing, returns, complaints
2. "data" - Data analysis, statistics, charts, numerical insights
3. "code" - Programming, code execution, technical development
4. "general" - General questions, weather, search, calculations

Respond with only the agent name (support, data, code, or general).`,
    temperature: 0.1,
  });

  return text.trim().toLowerCase();
}

export async function POST(req: Request) {
  try {
    const { messages } = await req.json();
    
    // Get the latest user message for routing
    const lastMessage = messages[messages.length - 1];
    if (lastMessage.role !== 'user') {
      return new Response('Invalid message format', { status: 400 });
    }

    // Route to appropriate agent
    const agentType = await routeToAgent(lastMessage.content);
    const agentEndpoint = AGENT_ENDPOINTS[agentType as keyof typeof AGENT_ENDPOINTS] || AGENT_ENDPOINTS.general;

    // Forward request to the selected agent
    const agentResponse = await fetch(`${req.url.replace('/agent-router', '')}${agentEndpoint.replace('/api', '')}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ messages }),
    });

    if (!agentResponse.ok) {
      throw new Error('Agent request failed');
    }

    // Stream the response from the selected agent
    return new Response(agentResponse.body, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'X-Selected-Agent': agentType,
      },
    });

  } catch (error) {
    console.error('Agent router error:', error);
    return new Response('Error routing request', { status: 500 });
  }
}
```

## Production Features

### Rate Limiting and Monitoring

```typescript middleware/rateLimit.ts
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

export async function rateLimit(
  userId: string, 
  endpoint: string, 
  maxRequests: number = 100, 
  windowMs: number = 60000
): Promise<{ allowed: boolean; remaining: number; resetTime: number }> {
  const key = `rate_limit:${userId}:${endpoint}`;
  const window = Math.floor(Date.now() / windowMs);
  const windowKey = `${key}:${window}`;

  const current = await redis.incr(windowKey);
  
  if (current === 1) {
    await redis.expire(windowKey, Math.ceil(windowMs / 1000));
  }

  const remaining = Math.max(0, maxRequests - current);
  const resetTime = (window + 1) * windowMs;

  return {
    allowed: current <= maxRequests,
    remaining,
    resetTime,
  };
}

export async function logAgentUsage(
  userId: string,
  agentType: string,
  toolsUsed: string[],
  responseTime: number
) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    userId,
    agentType,
    toolsUsed,
    responseTime,
  };

  await redis.lpush('agent_usage_logs', JSON.stringify(logEntry));
  await redis.ltrim('agent_usage_logs', 0, 10000); // Keep last 10k logs
}
```

### Cost Tracking

```typescript lib/costTracking.ts
interface CostTracker {
  trackAgentCall(
    agentType: string,
    tokensUsed: number,
    provider: string,
    model: string
  ): Promise<void>;
  
  getUserCosts(userId: string, timeframe: 'day' | 'week' | 'month'): Promise<number>;
}

export class AgentCostTracker implements CostTracker {
  private redis: Redis;

  constructor() {
    this.redis = new Redis(process.env.REDIS_URL!);
  }

  async trackAgentCall(
    agentType: string,
    tokensUsed: number,
    provider: string,
    model: string
  ): Promise<void> {
    const costPerToken = this.getCostPerToken(provider, model);
    const totalCost = tokensUsed * costPerToken;

    const today = new Date().toISOString().split('T')[0];
    const costKey = `agent_costs:${today}`;

    await this.redis.hincrbyfloat(costKey, agentType, totalCost);
    await this.redis.expire(costKey, 86400 * 31); // Expire after 31 days
  }

  private getCostPerToken(provider: string, model: string): number {
    // Simplified cost calculation - in production, use real pricing
    const costs: Record<string, number> = {
      'openai:gpt-4': 0.00003,
      'openai:gpt-3.5-turbo': 0.000002,
      'anthropic:claude': 0.000025,
      'deepseek:chat': 0.0000002,
    };

    return costs[`${provider}:${model}`] || 0.000001;
  }

  async getUserCosts(userId: string, timeframe: 'day' | 'week' | 'month'): Promise<number> {
    const days = timeframe === 'day' ? 1 : timeframe === 'week' ? 7 : 30;
    let totalCost = 0;

    for (let i = 0; i < days; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dateKey = date.toISOString().split('T')[0];
      
      const dayCosts = await this.redis.hgetall(`agent_costs:${dateKey}`);
      for (const cost of Object.values(dayCosts)) {
        totalCost += parseFloat(cost as string);
      }
    }

    return totalCost;
  }
}
```

## Usage Examples

### Page Integration

```tsx app/agents/page.tsx
import AgentChat from '@/components/AgentChat';

export default function AgentsPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="text-center mb-8">
        <h1 className="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
          AI Agent Assistant
        </h1>
        <p className="text-gray-600 mt-2 max-w-2xl mx-auto">
          Interact with intelligent AI agents that can perform actions, access tools, and help you accomplish tasks efficiently.
        </p>
      </div>
      
      <AgentChat />
      
      <div className="mt-8 text-center text-sm text-gray-500">
        <p>Powered by Adaptive AI with intelligent model routing</p>
      </div>
    </div>
  );
}
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Tool Design" icon="wrench">
    Design tools to be atomic, focused, and handle errors gracefully. Provide clear descriptions and parameter validation.
  </Card>
  <Card title="Agent Specialization" icon="target">
    Create specialized agents for different domains (support, data, code) rather than one general-purpose agent.
  </Card>
  <Card title="Error Handling" icon="shield">
    Implement comprehensive error handling for tool failures and provide fallback strategies.
  </Card>
  <Card title="Cost Management" icon="dollar-sign">
    Monitor agent usage and implement rate limiting to control costs while maintaining user experience.
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="RAG Agents" icon="database" href="/examples/vercel-ai-sdk/rag-chatbot">
    Combine agents with RAG for knowledge-enhanced capabilities
  </Card>
  <Card title="Real-time Agents" icon="clock" href="/examples/vercel-ai-sdk/realtime-agents">
    Build reactive agents that respond to live data and events
  </Card>
  <Card title="Multi-Modal Agents" icon="image" href="/examples/vercel-ai-sdk/multimodal-agents">
    Create agents that can process text, images, and other media types
  </Card>
  <Card title="Production Deployment" icon="server" href="/examples/production/agent-deployment">
    Deploy and scale agent systems in production environments
  </Card>
</CardGroup>